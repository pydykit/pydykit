{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to","text":""},{"location":"#what-is-pydykit","title":"What is <code>pydykit</code>?","text":"<p><code>pydykit</code> is a Python-based dynamics simulation toolkit for dynamical systems. The package is based on time stepping methods, which are discrete versions of the corresponding dynamics equations - either ordinary differential equations (ODEs) or differential-algebraic equations (DAEs).</p>"},{"location":"#how-to-install","title":"How to install?","text":"<p>Directly install from the Python Package Index (PyPI) with</p> <pre><code>pip install pydykit\n</code></pre> <p>or clone the repository and install the package locally, following these steps:</p> <ol> <li>Create a new virtual environment and activate it.    We recommend using <code>venv</code>:    <pre><code>python3.12 -m venv .venv\nsource .venv/bin/activate\n</code></pre></li> <li>Clone the repository</li> <li>Install in editable- / development-mode:    <pre><code>pip install --editable .\n</code></pre></li> <li>Run your first script, e.g.    <pre><code>python scripts/s*.py\n</code></pre></li> </ol>"},{"location":"#how-to-use","title":"How to use?","text":"<p>Check out the getting started to familiarize yourself with <code>pydykit</code> and examples for more details.</p>"},{"location":"#who-are-we","title":"Who are we?","text":"<ul> <li>Julian K. Bauer - Code architect - @JulianKarlBauer</li> <li>Philipp L. Kinon - Core developer - @plkinon</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>A <code>pydykit</code>-simulation contains several building blocks, which are at least a <code>system</code>, <code>integrator</code>, <code>simulator</code> and a <code>time_stepper</code>. These building blocks are defined within a config file.</p>"},{"location":"getting_started/#config-file","title":"Config File","text":"<p>A <code>pydykit</code>-config file configures a simulation devided into several building blocks. Each building blocks consists of parameters and methods. Example config files can be found in pydykit/example_files and some of them are discussed in more detail in the section examples.</p>"},{"location":"getting_started/#system","title":"System","text":"<p>The <code>system</code> defines the system of ordinary differential equations (ODEs) or differential algebraic equations (DAEs), to be solved. <code>Pydykit</code> covers three system families, which are:</p> <ol> <li>Multibody systems</li> <li>Port-Hamiltonian systems</li> <li>Quasilinear DAEs</li> </ol> <p>Lets briefly introduce them one by one.</p>"},{"location":"getting_started/#1-multibody-system-mbs-dynamics","title":"1. Multibody system (MBS) dynamics","text":"<p>This family covers DAEs belonging to mechanical systems composed of multiple rigid bodies, governed by</p> \\[ \\begin{align} \\dot q &amp;= M^{-1} p \\\\ \\dot p &amp;= -\\nabla V(q) - D(q) M^{-1} p - \\nabla g(q)^{\\mathrm{T}} \\lambda \\\\ 0 &amp;= g(q) \\end{align} \\] <p>where \\(q\\) and \\(p\\) are generalized coordinates and momenta, respectively, \\(M\\) is the mass matrix, \\(V\\) is the potential energy, \\(D\\) is the Rayleigh dissipation matrix and \\(g\\) are independent, holonomic constraint functions enforced by Lagrange multipliers \\(\\lambda\\). One example can be studied in more detail, the 3D pendulum.</p>"},{"location":"getting_started/#2-port-hamiltonian-systems-phs","title":"2. Port-Hamiltonian systems (PHS)","text":"<p>Port-Hamiltonian systems are an extension of classical Hamiltonian dyamics with respect to dissipative effects and interconnection terms from the environment. This energy-based approach combines dynamics from various physical disciplines in one formalism and emerges from control systems theory. The dynamics follow</p> \\[ \\begin{align} E(x) \\dot x &amp;= \\left( J(x) -R(x) \\right) z(x)  + B(x)u \\\\ E(x)^{\\mathrm{T}} z(x) &amp;= \\nabla H(x) \\\\ y &amp;= B(x)^{\\mathrm{T}} z(x) \\end{align} \\] <p>with state \\(x\\), co-state function \\(z\\), possibly singular descriptor matrix \\(E\\), structure matrix \\(J=-J^{\\mathrm{T}}\\), positive semi-definite dissipatrix matrix \\(R=R^{\\mathrm{T}}\\), input matrix \\(B\\), control input \\(u\\) with collocated output \\(y\\) and Hamiltonian \\(H\\).</p>"},{"location":"getting_started/#3-quasilinear-daes","title":"3. Quasilinear DAEs","text":"<p>This last framework is an even more general one. It comprises all DAEs of the general form</p> \\[ E(x) \\dot x = f(x,t) \\] <p>where \\(E\\) is a possibly singular descriptor matrix, \\(x\\) are the unknowns/states and \\(f\\) denotes an arbitrary right-hand side function. Examples that can be studied in more detail, are the Lorenz attractor and the chemical reactor.</p>"},{"location":"getting_started/#integrator","title":"Integrator","text":"<p>The <code>integrator</code> defines the numerical integration scheme to be used for the system at hand. As the integration scheme defines whether a numerical procedure preserves the underlying structure of the problem, <code>pydykit</code> places particular emphasis on integrator classed. Although a system may fit into even two or three of the abovementioned framework, the user might want to introduce specialized integrators to capture as much of the underlying structure as possible, e.g. exactly preserve the constraint functions of the MBS or the skew-symmetry of the structure matrix of a PHS.</p>"},{"location":"getting_started/#simulator","title":"Simulator","text":"<p>The <code>simulator</code> defines the solution procedure to be used. This includes the equation solver to be used, e.g. Newton's method and its characeteristics such as accuracy.</p>"},{"location":"getting_started/#time-stepper","title":"Time Stepper","text":"<p>The <code>time_stepper</code> defines the discrete temporal grid, where approximative solutions are computed. Currently, <code>pydykit</code> supports one-step methods only, i.e. for a known solution at one time-instance <code>pydykit</code> computes the solution at the next time instance on the specified grid.</p>"},{"location":"examples/list/","title":"List Examples","text":"<p>Examples shipped with <code>pydykit</code> can accessed with <code>pydykit.examples.ExampleManager</code>. This is demonstrated by the list of available examples within the tab <code>Result</code> shown below. The source code generating this list, is shown in tab <code>Source</code>.</p> ResultSource <p><ul> <li>four_particle_system_discrete_gradient_dissipative config file</li> <li>four_particle_system_midpoint config file</li> <li>four_particle_system_ph_discrete_gradient_dissipative config file</li> <li>four_particle_system_ph_midpoint config file</li> <li>lorenz config file</li> <li>pendulum_2d config file</li> <li>pendulum_3d config file</li> <li>reactor config file</li> <li>rigid_body_rotating_quaternion config file</li> <li>two_particle_system config file</li> <li>visco_pendulum config file</li> </ul> </p> <pre><code>from markdown import markdown\n\nfrom pydykit import examples\n\nexample_manager = examples.ExampleManager()\nkeys = example_manager.examples.keys()\n\nbase_url = example_manager.BASE_URL_EXAMPLE_FILES\nhtml = markdown(\n    \"\\n\".join([f\"- {item} [config file]({base_url}{item}.yml)\" for item in keys])\n)\nprint(html)\n</code></pre>"},{"location":"examples/lorenz/","title":"Lorenz System","text":"<p>Let's use the system class <code>pydykit.systems_dae.Lorenz</code> to simulate the famous Lorenz attractor, which is modelled in terms a quasilinear differential algebraic equations.</p> ResultSource <p> </p> <pre><code>import plotly.graph_objects as go\n\nfrom pydykit.configuration import Configuration\nfrom pydykit.examples import ExampleManager\nfrom pydykit.managers import Manager\nfrom pydykit.plotters import Plotter\n\n####### Simulation\nfile_content = ExampleManager().get_example(name=\"lorenz\")\nconfiguration = Configuration(**file_content)  # Validate config file content\n\nmanager = Manager()\nmanager.configure(configuration=configuration)\n\nresult = manager.manage()  # Run the simulation\n\n####### Plotting\nfig = go.Figure()\ndf = result.to_df()\nplotter = Plotter(results_df=df)\nplotter.plot_3d_trajectory(\n    figure=fig,\n    x_components=df[\"x\"],\n    y_components=df[\"y\"],\n    z_components=df[\"z\"],\n    time=df[\"time\"],\n)\nplotter.fix_scene_bounds_to_extrema(figure=fig, df=df)\n\n####### Show visualization\nscript_is_executed_on_local_machine = False  # You might want to change this\n\nif script_is_executed_on_local_machine:\n    fig.show()\nelse:\n    print(\n        fig.to_html(\n            full_html=False,\n            include_plotlyjs=\"cdn\",\n        )\n    )\n</code></pre>"},{"location":"examples/lorenz/#config-file","title":"Config File","text":"<p>The configuration file of this simulation reads as</p> <pre><code>name: lorenz\nsystem:\n  class_name: Lorenz\n  sigma: 10.0\n  rho: 28.0\n  beta: 2.6666666667\n  state:\n    state: [2.0, 1.0, 1.0]\nsimulator:\n  class_name: OneStep\n  solver_name: NewtonPlainPython\n  newton_epsilon: 1.e-07\n  max_iterations: 40\nintegrator:\n  class_name: MidpointDAE\ntime_stepper:\n  class_name: FixedIncrement\n  step_size: 0.02\n  start: 0.0\n  end: 4.0\n</code></pre> <p>For details on the usage of <code>class_name</code>-variable, see the example <code>Pendulum 3D</code>.</p>"},{"location":"examples/pendulum_3d/","title":"Pendulum 3D","text":"<p>Let's use the system class <code>pydykit.systems_multi_body.ParticleSystem</code> to simulate a single particle with concentrated mass within a three-dimensional space.</p> <p>The particle's initial position is <code>(1.0, 0.0, 0.0)</code> and its initial velocity points into the <code>y</code>-direction. The particle's distance to a fixed support at <code>(0.0, 0.0, 0.0)</code> is constraint to be of length <code>1.0</code> and there is a gravitational field into negative <code>z</code>-direction.</p> <p>In consequence, the particle is called a 3D pendulum and its motion is visualized in belows <code>Result</code> tab. The source code of leading to this viosualization is given within the <code>Source</code> tab.</p> ResultSource <p> </p> <pre><code>import plotly.graph_objects as go\n\nfrom pydykit.configuration import Configuration\nfrom pydykit.examples import ExampleManager\nfrom pydykit.managers import Manager\nfrom pydykit.plotters import Plotter\n\n####### Simulation\nfile_content = ExampleManager().get_example(name=\"pendulum_3d\")\nconfiguration = Configuration(**file_content)  # Validate config file content\n\nmanager = Manager()\nmanager.configure(configuration=configuration)\n\nresult = manager.manage()  # Run the simulation\n\n####### Plotting\ndf = result.to_df()\nfig = go.Figure()\nplotter = Plotter(results_df=df)\nfor index in range(manager.system.nbr_particles):\n    plotter.plot_3d_trajectory(\n        figure=fig,\n        x_components=df[f\"position0_particle{index}\"],\n        y_components=df[f\"position1_particle{index}\"],\n        z_components=df[f\"position2_particle{index}\"],\n        time=df[\"time\"],\n    )\n    index_time = 0\n    plotter.add_3d_annotation(\n        figure=fig,\n        x=df[f\"position0_particle{index}\"][index_time],\n        y=df[f\"position1_particle{index}\"][index_time],\n        z=df[f\"position2_particle{index}\"][index_time],\n        text=f\"start of particle {index}\",\n    )\nplotter.fix_scene_bounds_to_extrema(figure=fig, df=df)\n\n####### Show visualization\nscript_is_executed_on_local_machine = False  # You might want to change this\n\nif script_is_executed_on_local_machine:\n    fig.show()\nelse:\n    print(\n        fig.to_html(\n            full_html=False,\n            include_plotlyjs=\"cdn\",\n        )\n    )\n</code></pre>"},{"location":"examples/pendulum_3d/#config-file","title":"Config File","text":"<p>Let's have a closer look at the configuration file of this simulation:</p> <pre><code>name: pendulum_3d\nsystem:\n  class_name: ParticleSystem\n  nbr_spatial_dimensions: 3\n  particles:\n    - index: 0\n      initial_position: [1.0, 0.0, 0.0]\n      initial_momentum: [0.0, 1.0, 0.0]\n      mass: 1.0\n  supports:\n    - index: 0\n      type: fixed\n      position: [0.0, 0.0, 0.0]\n  springs: []\n  dampers: []\n  constraints:\n    - start:\n        type: support\n        index: 0\n      end:\n        type: particle\n        index: 0\n      length: 1.0\n  gravity: [0.0, 0.0, -9.81]\nintegrator:\n  class_name: MidpointMultibody\nsimulator:\n  class_name: OneStep\n  solver_name: NewtonPlainPython\n  newton_epsilon: 1.e-07\n  max_iterations: 40\ntime_stepper:\n  class_name: FixedIncrementHittingEnd\n  step_size: 0.08\n  start: 0.0\n  end: 1.3\n</code></pre>"},{"location":"examples/pendulum_3d/#system","title":"System","text":"<p>The <code>system</code>-section in the above configuration file defines the scene, aka. system, to be simulated. This includes definition of the particle, the fixed support, the constraint and the gravitation.</p> <p>The <code>system</code>-sections variable <code>class_name</code> tells <code>pydykit</code> that the scene shall be based on the system class <code>ParticleSystem</code>, which belongs to the family of MBS. This class is known to <code>pydykit</code> as it has been registered within the <code>SystemFactory</code>.</p>"},{"location":"examples/pendulum_3d/#integrator","title":"Integrator","text":"<p>The <code>integrator</code>-section in the above configuration file defines the integration scheme to be used. Here, the implicit midpoint rule will be applied to the system which is formulated as a MBS.</p> <p>Similar to the registration pattern of the <code>system</code>, the variable <code>class_name</code> within section <code>integrator</code> tells <code>pydykit</code> to use the class <code>MidpointMultibody</code>. This class is known to <code>pydykit</code> as it has been registered within the <code>IntegratorFactory</code>. The pattern of referencing a registered Python class in terms of <code>class_name</code> also applies to the sections <code>simulator</code> and <code>time_stepper</code>.</p>"},{"location":"examples/pendulum_3d/#simulator","title":"Simulator","text":"<p>The <code>simulator</code>-section defines the solution procedure, aka. simulator, to be used. The simulator uses a Newton method with a specific accuracy for the norm of the residual <code>newton_epsilon</code> and a maximum number of iterations per time step before the simulation procedure is stopped.</p>"},{"location":"examples/pendulum_3d/#time-stepper","title":"Time Stepper","text":"<p>The <code>time_stepper</code>-section defines the time stepping algorithm based on settings for start time, end time and step size.</p>"},{"location":"examples/reactor/","title":"Chemical Reactor","text":"<p>Let's use the system class <code>pydykit.systems_dae.ChemicalReactor</code> to represent a chemical reactor in terms of a differential-algebraic system and solve it's behavior in time. This system is modelled as quasilinear differential-algebraic equations.</p> ResultSource <p> </p> <pre><code>import plotly.graph_objects as go\n\nfrom pydykit.configuration import Configuration\nfrom pydykit.examples import ExampleManager\nfrom pydykit.managers import Manager\nfrom pydykit.plotters import Plotter\n\n####### Simulation\nfile_content = ExampleManager().get_example(name=\"reactor\")\nconfiguration = Configuration(**file_content)  # Validate config file content\n\nmanager = Manager()\nmanager.configure(configuration=configuration)\n\nresult = manager.manage()  # Run the simulation\n\n####### Plotting\nfig = go.Figure()\ndf = result.to_df()\nplotter = Plotter(results_df=df)\nplotter.plot_3d_trajectory(\n    figure=fig,\n    x_components=df[\"concentration\"],\n    y_components=df[\"temperature\"],\n    z_components=df[\"reaction_rate\"],\n    time=df[\"time\"],\n)\n\n####### Show visualization\nscript_is_executed_on_local_machine = False  # You might want to change this\n\nif script_is_executed_on_local_machine:\n    fig.show()\nelse:\n    print(\n        fig.to_html(\n            full_html=False,\n            include_plotlyjs=\"cdn\",\n        )\n    )\n</code></pre>"},{"location":"examples/reactor/#config-file","title":"Config File","text":"<p>The configuration file of this simulation reads as</p> <pre><code>name: reactor\nsystem:\n  class_name: ChemicalReactor\n  constants: [1.0, 1.0, 1.0, -100.0]\n  cooling_temperature: 10.0\n  reactant_concentration: 0.5\n  initial_temperature: 50.0\n  state:\n    state: [0.0, 50.0, 0.0]\nsimulator:\n  class_name: OneStep\n  solver_name: NewtonPlainPython\n  newton_epsilon: 1.e-10\n  max_iterations: 40\nintegrator:\n  class_name: MidpointDAE\ntime_stepper:\n  class_name: FixedIncrement\n  step_size: 0.01\n  start: 0.0\n  end: 1\n</code></pre> <p>For details on the usage of <code>class_name</code>-variable, see the example <code>Pendulum 3D</code>.</p>"}]}